## Overview

The application continuously engages users by presenting new questions generated by OpenAI based on user-written prompts. It uses Docker for consistent deployment and Auth0 for secure user authentication.

## Key Technologies

- **FastAPI:** Chosen for its performance, asynchronous support, and automatic Swagger documentation.
- **AWS Lambda:** Manages CRUD operations in a serverless environment.
- **PostgreSQL:** Database with SQLAlchemy ORM and Alembic for schema migrations.
- **Auth0:** Provides robust authentication, including social login and multi-factor authentication.
- **Docker:** Ensures uniform deployment across environments.
- **OpenAI API:** Central to generating questions for a continuous learning experience.

## Database Structure

- **Users:** Stores user identification, profile information, and authentication details.
- **Prompts:** Records user-generated prompts.
- **Questions:** Stores questions generated by OpenAI from the prompts.
- **Responses:** Captures user answers for further analysis.

![Database](./diagrams/schema-with-options.png)

The production database, used in the live version, is hosted on AWS as an RDS-Postgres instance. In contrast, the local database is generated using `docker-compose up`. Once started, it is necessary to execute the migration commands to work with the database locally.

## CRUD Operations

- **Users:** Manage user accounts with full CRUD operations.
- **Prompts and Questions:** Users can create prompts; admins manage the generated questions.
- **Responses:** Users submit responses, admins can read and delete them.

## Application Flow

1. **User Login:** Users log in and see a random question.
2. **Prompt Submission:** Users submit a prompt, e.g., “What do you want to study today?”
3. **Question Display:** A new question related to the prompt is shown.
4. **Response and Storage:** Users submit their answers, which are saved in the system.
5. **Continuous Engagement:** A new question is displayed immediately after each response, keeping users engaged.

![Application Flow](./diagrams/application_flow.png)

## Development Timeline

The project is structured into a four-week sprint covering backend setup, integration, testing, and deployment.

## Live Version

You can view the live version at: [Your Live Version URL]

[https://3sq1oyp08f.execute-api.us-east-1.amazonaws.com/Prod/docs](https://3sq1oyp08f.execute-api.us-east-1.amazonaws.com/Prod/docs).

## Project Layout

The SAM CLI builds and packages the app from the contents of the `/src` directory as specified in `template.yaml` in the project root.

The `/src` directory contains the FastAPI app in `/src/app` and a `requirements.txt` file that specifies the Python runtime dependencies.

Since the frontend is served from FastAPI, frontend build artifacts are generated in `/src/frontend` in order to be included in the SAM build.

The `/frontend` folder contains the Vue 3 frontend as a self-contained project created with `npm create vue@latest`.

```bash
/src
  /app
    main.py          # FastAPI app
  /frontend          # frontend build artifacts
  requirements.txt   # Python dependencies
  /tests
```

## Local Development

1. **Navigate to the `src` Directory:**

   ```bash
   cd src
   ```

2. **Database Setup:**

   Before starting Docker Compose, ensure the database setup script has the correct permissions and line endings.

   The `docker-compose up -d` command relies on a script located at `./src/scripts/db-setup.sh`. This script sets up the PostgreSQL database as follows:

   ```sh
   #!/bin/sh

   export PGUSER="postgres"

   psql -c "CREATE DATABASE fastapi"

   psql fastapi -c "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";"
   ```

   **Important Notes:**
   
   - Ensure the script has LF (Line Feed) line endings, not CRLF, as it will be executed in a PostgreSQL environment.
   - To set the correct line endings in Visual Studio Code, make sure the file is in LF format (look for "LF" or "CRLF" in the bottom right corner of VS Code).
   - Grant execution permissions to the script with the following command:

     ```bash
     chmod +x ./src/scripts/db-setup.sh
     ```

3. **Start Docker Compose:**

   ```bash
   docker-compose up -d
   ```

4. **Create a Virtual Environment:**

   ```bash
   python -m venv venv
   ```

5. **Activate the Virtual Environment:**

   - **Windows:**

     ```bash
     .\venv\Scripts\activate
     ```

   - **macOS/Linux:**

     ```bash
     source venv/bin/activate
     ```

6. **Install Poetry Dependencies:**

   ```bash
   poetry install
   ```

7. **Generate Migrations for an Empty Database:**

   ```bash
   alembic -n devdb revision --autogenerate -m "init"
   alembic -n devdb upgrade head
   ```

   The `-n` flag specifies the name of the database connection, `devdb`, which is defined in the Alembic configuration file.

8. **Run the Application:**

   ```bash
   python -m app.main
   ```

9. **Open Swagger Documentation:**

    Visit [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs) to view and interact with the API endpoints in Swagger.

## Environment Variables Configuration

To run the application locally, you need to configure the environment variables. This is done by copying the `.env.example` file to a `.env` file and setting the necessary variables.

1. **Copy the Example File:**

   ```bash
   cp .env.example .env
   ```

2. **Edit the `.env` File:**

   Open the `.env` file in your preferred text editor and set the following variables:

   ```env
      # URLs de las bases de datos de desarrollo y prueba
      DEV_DATABASE_URL=""
      TEST_DATABASE_URL=postgresql+psycopg2://postgres:postgres@127.0.0.1:5434/fastapi

      # Credenciales de PostgreSQL (asegúrate de que coincidan con las configuradas en docker-compose.yml)
      POSTGRES_USER="postgres"
      POSTGRES_PASSWORD="postgres"

      # Configuración Auth0
      AUTH0_DOMAIN=""
      AUTH0_CLIENT_ID=""
      AUTH0_CLIENT_SECRET=""
      AUTH0_AUDIENCE=""

      # Dirección del frontend
      FRONT_HOST="http://localhost:3000/"

      # Clave secreta para la aplicación
      SECRET_KEY="ASDFASDF"

      # Clave API de OpenAI
      OPENAI_API_KEY=""

      # Variable para configurar el entorno de testing
      TESTING="2"
   ```

## Python Dependency Management with Poetry

This project uses [Poetry](https://python-poetry.org/) for dependency management.

Poetry organizes dependencies in groups, and this project distinguishes the following groups:

- `main` - dependencies for the FastAPI app
- `dev` - dependencies specifically for development
- `test` - dependencies for running tests with pytest
- `code-qa` - dependencies for code quality checks

The `main` group is the only one that is needed for the deployed app. Therefore, the `requirements.txt` file in the `/src` directory is a direct dependency of the `poetry.lock` file.

As such, it is generated from the `poetry.lock` file with only dependencies from the `main` group using the `poetry export` command.

This happens automatically as part of pre-commit hooks (see `/pre-commit-config.yaml`).

You can update it manually with:

```bash
poetry export -f requirements.txt --only main --output requirements.txt --without-hashes
```


## Using API in Swagger

When using Swagger to interact with the API or make requests, you do not need to include the "user_id" attribute in the request bodies. This attribute is used only for testing purposes. In actual API usage, the "user_id" is automatically obtained from the authorization token (Bearer Token) that provides the ID of the authenticated user.

### Configuring Bearer Token Authentication in Swagger

1. **Access the Authorization Button:**

   In the Swagger interface, find the "Authorize" button at the top right corner of the page.

   ![Swagger Authorization Button](./diagrams/swagger_authorize_button.png)

2. **Enter the Bearer Token:**

   Click on the "Authorize" button to open a pop-up window. In this window, enter your Bearer Token in the provided field. Make sure to prefix your token with the word "Bearer" followed by a space.

   ```plaintext
   Bearer <your_access_token>
   ```

   ![Token Input Window](./diagrams/swagger_authorize_window.png)

   For example, if your access token is `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`, you should enter it as:

   ```plaintext
   Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
   ```

3. **Apply Authorization:**

   Click the "Authorize" button in the pop-up window to apply the authentication to your requests. After authorizing, you can close the pop-up and start making authenticated API requests.

### Example

When you make a request with Swagger, the request body does not need to include "user_id". Here’s how a correct request should look:

![Request without user_id](./diagrams/endpoint_without_user_id_body_example.png)

In this case, the API extracts the "user_id" from the Bearer Token you provided in the authorization step.

## Authentication and Authorization

The implementation of the API endpoints uses the Bearer Token to manage both user authentication and authorization. This token is passed in the request headers and is used to verify the user's identity and access permissions.

### Authentication

When a user logs in, they receive an `access_token` from Auth0. This token must be included as a Bearer Token in the Authorization header of all API requests. The Bearer Token is used to identify the authenticated user in each request.

The access token (`access_token`) is included in the HTTP header as follows:

```http
Authorization: Bearer <your_access_token>
```

### Authorization

The Bearer Token is also used to verify the user’s permissions to access specific endpoints. The API validates the token to determine if the user has the necessary roles and permissions to perform certain actions.

### Example Endpoints

- **Check if the User is Logged In:**

  ```python
  @questions_router.get(
      "/random-question",
      response_model=QuestionResult,
      status_code=201,
      dependencies=[Depends(AuthenticationChecker())],
  )
  ```

  In this example, `AuthenticationChecker` is used as a dependency to ensure the user is logged in before they can access the endpoint to get a random question. The `AuthenticationChecker` takes the Bearer Token from the Authorization header to verify authentication.

- **Check if the User Has Specific Role Permissions:**

  ```python
  @user_router.put(
      "/{user_id}/admin",
      response_model=UserReturn,
      status_code=200,
      dependencies=[Depends(PermissionsValidator(["crud:admin-update-user"]))],
  )
  ```

  Here, `PermissionsValidator` checks if the user has the required role permissions to update user information. Specifically, it checks for the `crud:admin-update-user` permission. The `PermissionsValidator` uses the Bearer Token to validate if the user has the appropriate permissions.

### How It Works

1. **Login:** The user logs in and receives an `access_token` from Auth0.
2. **Pass the Token:** This token must be included in all requests as a Bearer Token in the Authorization header.
3. **Token Validation:** The API uses the Bearer Token to verify if the user is authenticated and if they have the necessary permissions to access the endpoints.

This approach ensures secure access control, allowing only authenticated and authorized users to perform certain actions based on their roles.


### How It Works

1. **Login:** The user logs in and receives an `access_token` from Auth0.
2. **Store Token:** The `access_token` is stored in the cookies with the name "session".
3. **Validation:** Validators (`AuthenticationChecker` and `PermissionsValidator`) use this token# railyawtr
